// migrationRunner.js - Simple migration runner for OracleDB
const fs = require("fs");
const path = require("path");
const oracledb = require("oracledb");
const dbConfig = require("./dbConfig");

const MIGRATIONS_DIR = path.join(__dirname, "migrations");

async function ensureMigrationsTable(conn) {
  // Create a table to track applied migrations
  const sql = `CREATE TABLE migrations (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    filename VARCHAR2(255) UNIQUE NOT NULL,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  )`;
  try {
    await conn.execute(sql);
    await conn.commit();
    console.log("Created migrations table.");
  } catch (err) {
    if (err.errorNum === 955) {
      // ORA-00955: name is already used by an existing object
      // Table already exists, ignore
    } else {
      throw err;
    }
  }
}

module.exports = runMigrations;
async function getAppliedMigrations(conn) {
  const result = await conn.execute("SELECT filename FROM migrations");
  return result.rows.map((row) => row[0]);
}

async function runMigrations() {
  const files = fs
    .readdirSync(MIGRATIONS_DIR)
    .filter((f) => f.endsWith(".sql"))
    .sort();
  let conn;
  try {
    conn = await oracledb.getConnection(dbConfig);
    await ensureMigrationsTable(conn);
    const applied = await getAppliedMigrations(conn);
    for (const file of files) {
      if (!applied.includes(file)) {
        const sql = fs.readFileSync(path.join(MIGRATIONS_DIR, file), "utf8");
        // Build executable statements while preserving newlines so -- comments don't swallow SQL
        // Handle:
        //  - PL/SQL blocks delimited by a single '/' on its own line
        //  - Regular SQL statements terminated by ';' at end of line
        //  - Skip line and block comments outside PL/SQL blocks
        const blocks = [];
        let buffer = [];
        const lines = sql.split(/\r?\n/);
        let inPlsql = false;
        let inBlockComment = false; // /* ... */
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i];

          // Track/strip block comments when not inside PL/SQL
          if (!inPlsql) {
            if (inBlockComment) {
              if (/\*\//.test(line)) {
                inBlockComment = false;
                line = line.replace(/^.*?\*\//, "");
              } else {
                continue; // still inside block comment
              }
            }
            // Start of block comment
            if (/\/\*/.test(line)) {
              inBlockComment = true;
              // remove from /* to end-of-line
              line = line.replace(/\/\*.*$/, "");
            }
            // Remove single-line comments
            line = line.replace(/--.*$/, "");
          }

          if (
            /^\s*CREATE\s+OR\s+REPLACE\s+(PROCEDURE|FUNCTION|TRIGGER)\b/i.test(
              line
            )
          ) {
            inPlsql = true;
            buffer.push(line);
            continue;
          }

          if (inPlsql && /^\s*\/$/.test(line)) {
            // End of PL/SQL block, push the block as-is (preserve newlines)
            const stmt = buffer.join("\n").trim();
            if (stmt) blocks.push(stmt);
            buffer = [];
            inPlsql = false;
            continue;
          }

          if (inPlsql) {
            buffer.push(line);
            continue;
          }

          // Outside PL/SQL: collect regular SQL until semicolon at end of line
          if (/;\s*$/.test(line)) {
            const withoutTerminator = line.replace(/;\s*$/, "");
            buffer.push(withoutTerminator);
            const stmt = buffer.join("\n").trim();
            if (stmt) blocks.push(stmt);
            buffer = [];
          } else if (line.trim() !== "") {
            buffer.push(line);
          }
        }
        if (buffer.length > 0) {
          const tail = buffer.join("\n").trim();
          if (tail) blocks.push(tail);
        }

        let allSucceeded = true;
        for (const stmt of blocks) {
          if (stmt) {
            try {
              console.log("Executing:", stmt.split("\n")[0]);
              await conn.execute(stmt);
            } catch (err) {
              // Skip 'already exists' errors
              if (
                err.errorNum &&
                [955, 942, 2261, 2275].includes(err.errorNum)
              ) {
                console.log(`Skip (already exists):`, stmt.split("\n")[0]);
                continue;
              } else {
                allSucceeded = false;
                console.error(
                  `Error executing statement in ${file}:`,
                  stmt.split("\n")[0],
                  err.message
                );
                break;
              }
            }
          }
        }
        if (allSucceeded) {
          await conn.execute(
            "INSERT INTO migrations (filename) VALUES (:filename)",
            [file]
          );
          await conn.commit();
          console.log("Applied migration:", file);
        } else {
          console.error(`Migration ${file} failed. Not marking as applied.`);
        }
      }
    }
    console.log("All migrations applied.");
  } catch (err) {
    console.error("Migration error:", err);
  } finally {
    if (conn) await conn.close();
  }
}
