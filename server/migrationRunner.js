// migrationRunner.js - Simple migration runner for OracleDB
const fs = require("fs");
const path = require("path");
const oracledb = require("oracledb");
const dbConfig = require("./dbConfig");

const MIGRATIONS_DIR = path.join(__dirname, "migrations");

async function ensureMigrationsTable(conn) {
  // Create a table to track applied migrations
  const sql = `CREATE TABLE migrations (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    filename VARCHAR2(255) UNIQUE NOT NULL,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  )`;
  try {
    await conn.execute(sql);
    await conn.commit();
    console.log("Created migrations table.");
  } catch (err) {
    if (err.errorNum === 955) {
      // ORA-00955: name is already used by an existing object
      // Table already exists, ignore
    } else {
      throw err;
    }
  }
}

module.exports = runMigrations;
async function getAppliedMigrations(conn) {
  const result = await conn.execute("SELECT filename FROM migrations");
  return result.rows.map((row) => row[0]);
}

async function runMigrations() {
  const files = fs
    .readdirSync(MIGRATIONS_DIR)
    .filter((f) => f.endsWith(".sql"));
  let conn;
  try {
    conn = await oracledb.getConnection(dbConfig);
    await ensureMigrationsTable(conn);
    const applied = await getAppliedMigrations(conn);
    for (const file of files) {
      if (!applied.includes(file)) {
        const sql = fs.readFileSync(path.join(MIGRATIONS_DIR, file), "utf8");
        // Split on semicolon at end of line (handles ; with or without newline)
        // Split on semicolon followed by optional whitespace and a line ending or end of file
        // Split into PL/SQL blocks (ending with / on its own line) and regular SQL (ending with ;)
        const blocks = [];
        let buffer = [];
        const lines = sql.split(/\r?\n/);
        let inPlsql = false;
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (
            /^\s*CREATE OR REPLACE (PROCEDURE|FUNCTION|TRIGGER)/i.test(line)
          ) {
            inPlsql = true;
            buffer.push(line);
          } else if (inPlsql && /^\s*\/$/.test(line)) {
            // End of PL/SQL block
            blocks.push(buffer.join("\n"));
            buffer = [];
            inPlsql = false;
          } else if (inPlsql) {
            buffer.push(line);
          } else if (/;\s*$/.test(line)) {
            // End of regular SQL statement
            buffer.push(line);
            blocks.push(buffer.join(" "));
            buffer = [];
          } else if (line.trim() !== "") {
            buffer.push(line);
          }
        }
        if (buffer.length > 0) {
          blocks.push(buffer.join(" "));
        }

        let allSucceeded = true;
        for (const stmt of blocks) {
          if (stmt) {
            try {
              console.log("Executing:", stmt.split("\n")[0]);
              await conn.execute(stmt);
            } catch (err) {
              // Skip 'already exists' errors
              if (
                err.errorNum &&
                [955, 942, 2261, 2275].includes(err.errorNum)
              ) {
                console.log(`Skip (already exists):`, stmt.split("\n")[0]);
                continue;
              } else {
                allSucceeded = false;
                console.error(
                  `Error executing statement in ${file}:`,
                  stmt.split("\n")[0],
                  err.message
                );
                break;
              }
            }
          }
        }
        if (allSucceeded) {
          await conn.execute(
            "INSERT INTO migrations (filename) VALUES (:filename)",
            [file]
          );
          await conn.commit();
          console.log("Applied migration:", file);
        } else {
          console.error(`Migration ${file} failed. Not marking as applied.`);
        }
      }
    }
    console.log("All migrations applied.");
  } catch (err) {
    console.error("Migration error:", err);
  } finally {
    if (conn) await conn.close();
  }
}
